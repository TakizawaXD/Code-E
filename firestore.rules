/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data and allows public read access to course content while restricting write access to authorized users.
 *
 * Data Structure:
 * - Users: /users/{userId} (profile information)
 * - Learning Paths: /learningPaths/{learningPathId}
 * - Courses: /learningPaths/{learningPathId}/courses/{courseId}
 * - Lessons: /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}
 * - Comments: /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/comments/{commentId}
 * - Exercises: /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/exercises/{exerciseId}
 * - Progress: /users/{userId}/progress/{progressId}
 * - Certificates: /users/{userId}/certificates/{certificateId}
 * - Payments: /users/{userId}/payments/{paymentId}
 * - Exams: /courses/{courseId}/exams/{examId}
 * - Exam Questions: /courses/{courseId}/exams/{examId}/examQuestions/{examQuestionId}
 * - User Exam Answers: /users/{userId}/userExamAnswers/{userExamAnswerId}
 *
 * Key Security Decisions:
 * - User data (profiles, progress, certificates, payments, exam answers) is strictly controlled by the owning user.
 * - Course and learning path data (learning paths, courses, lessons, comments, exercises, exams, exam questions) is publicly readable.
 * - Listing of user documents is allowed only for the owner, except for listing learning paths, courses, lessons, and exercises.
 *
 * Denormalization for Authorization:
 * - User-specific data is nested under the /users/{userId} path to simplify ownership checks.
 *
 * Structural Segregation:
 * - Private user data is stored under /users/{userId}, while public course content is stored under /learningPaths/{learningPathId}.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access only to the owner of the user document.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' creates their own profile.
     *   - auth.uid: 'user123'
     *   - request.resource.data.id: 'user123'
     * @allow (get, update, delete, list) - User with ID 'user123' reads, updates, or deletes their own profile.
     *   - auth.uid: 'user123'
     * @deny (create) - User with ID 'user123' tries to create a profile for another user ('user456').
     *   - auth.uid: 'user123'
     *   - request.resource.data.id: 'user456'
     * @deny (get, update, delete) - User with ID 'user123' tries to read, update, or delete the profile of another user ('user456').
     *   - auth.uid: 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      // Helper function to check if the request is made by the owner
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      //Helper function to check if the request is made by an existing owner
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to learning paths.
     * @path /learningPaths/{learningPathId}
     * @allow (get, list) - Any user can read learning path details.
     * @deny (create, update, delete) - Only authorized users can modify learning paths.
     * @principle Allows public read access while restricting write access.
     */
    match /learningPaths/{learningPathId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Allows public read access to courses within learning paths.
     * @path /learningPaths/{learningPathId}/courses/{courseId}
     * @allow (get, list) - Any user can read course details.
     * @deny (create, update, delete) - Only authorized users can modify courses.
     * @principle Allows public read access while restricting write access.
     */
    match /learningPaths/{learningPathId}/courses/{courseId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Allows public read access to lessons within courses.
     * @path /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}
     * @allow (get, list) - Any user can read lesson details.
     * @deny (create, update, delete) - Only authorized users can modify lessons.
     * @principle Allows public read access while restricting write access.
     */
    match /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Allows public read access to comments on lessons, but restricts write access to authenticated users who own the comment.
     * @path /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/comments/{commentId}
     * @allow (get, list) - Any user can read comments.
     * @allow (create) - Any authenticated user can create a comment.
     * @allow (update, delete) - Only the owner of the comment can update or delete it.
     * @deny (update, delete) - A user tries to update or delete a comment they don't own.
     * @principle Allows public read access and restricts write access to comment owners.
     */
    match /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/comments/{commentId} {
        function isOwner(userId) {
            return request.auth != null && request.auth.uid == userId;
        }

        function isExistingOwner(userId) {
            return isOwner(userId) && resource != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isExistingOwner(resource.data.userId);
        allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows public read access to exercises within lessons.
     * @path /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/exercises/{exerciseId}
     * @allow (get, list) - Any user can read exercise details.
     * @deny (create, update, delete) - Only authorized users can modify exercises.
     * @principle Allows public read access while restricting write access.
     */
    match /learningPaths/{learningPathId}/courses/{courseId}/lessons/{lessonId}/exercises/{exerciseId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Grants access only to the owner of the progress document.
     * @path /users/{userId}/progress/{progressId}
     * @allow (create) - User with ID 'user123' creates their own progress document.
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get, update, delete, list) - User with ID 'user123' reads, updates, or deletes their own progress document.
     *   - auth.uid: 'user123'
     * @deny (create) - User with ID 'user123' tries to create a progress document for another user ('user456').
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user456'
     * @deny (get, update, delete) - User with ID 'user123' tries to read, update, or delete the progress document of another user ('user456').
     *   - auth.uid: 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/progress/{progressId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Grants access only to the owner of the certificate document.
     * @path /users/{userId}/certificates/{certificateId}
     * @allow (create) - User with ID 'user123' creates their own certificate document.
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get, update, delete, list) - User with ID 'user123' reads, updates, or deletes their own certificate document.
     *   - auth.uid: 'user123'
     * @deny (create) - User with ID 'user123' tries to create a certificate document for another user ('user456').
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user456'
     * @deny (get, update, delete) - User with ID 'user123' tries to read, update, or delete the certificate document of another user ('user456').
     *   - auth.uid: 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/certificates/{certificateId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Grants access only to the owner of the payment document.
     * @path /users/{userId}/payments/{paymentId}
     * @allow (create) - User with ID 'user123' creates their own payment document.
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get, update, delete, list) - User with ID 'user123' reads, updates, or deletes their own payment document.
     *   - auth.uid: 'user123'
     * @deny (create) - User with ID 'user123' tries to create a payment document for another user ('user456').
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user456'
     * @deny (get, update, delete) - User with ID 'user123' tries to read, update, or delete the payment document of another user ('user456').
     *   - auth.uid: 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/payments/{paymentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to exams within courses.
     * @path /courses/{courseId}/exams/{examId}
     * @allow (get, list) - Any user can read exam details.
     * @deny (create, update, delete) - Only authorized users can modify exams.
     * @principle Allows public read access while restricting write access.
     */
    match /courses/{courseId}/exams/{examId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Allows public read access to exam questions within exams.
     * @path /courses/{courseId}/exams/{examId}/examQuestions/{examQuestionId}
     * @allow (get, list) - Any user can read exam question details.
     * @deny (create, update, delete) - Only authorized users can modify exam questions.
     * @principle Allows public read access while restricting write access.
     */
    match /courses/{courseId}/exams/{examId}/examQuestions/{examQuestionId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin check once roles are defined.
    }

    /**
     * @description Grants access only to the owner of the user exam answer document.
     * @path /users/{userId}/userExamAnswers/{userExamAnswerId}
     * @allow (create) - User with ID 'user123' creates their own user exam answer document.
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get, update, delete, list) - User with ID 'user123' reads, updates, or deletes their own user exam answer document.
     *   - auth.uid: 'user123'
     * @deny (create) - User with ID 'user123' tries to create a user exam answer document for another user ('user456').
     *   - auth.uid: 'user123'
     *   - request.resource.data.userId: 'user456'
     * @deny (get, update, delete) - User with ID 'user123' tries to read, update, or delete the user exam answer document of another user ('user456').
     *   - auth.uid: 'user123'
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/userExamAnswers/{userExamAnswerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    // Helper function to check if the user is signed in
    function isSignedIn() {
      return request.auth != null;
    }
  }
}